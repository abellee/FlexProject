package{		import flash.display.Loader;	import flash.display.MovieClip;	import flash.display.Shape;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.net.URLRequest;		import mx.flash.UIMovieClip;		public class PageFlip extends UIMovieClip{				private var pointA:Point = new Point(0,0);		private var pointB:Point = new Point(660,0);		private var pointC:Point = new Point(0,500);		private var pointD:Point = new Point(660,500);		private var pointG:Point = new Point(330,250);		private var pointH:Point = new Point();		private var pointI:Point = new Point();		private var pointL:Point = new Point();		private var pointM:Point; // mouseX mouseY		private var pointK:Point = new Point();		private var masker:Shape = new Shape();		private var masker1:Shape = new Shape();		private var n:int= -1;		private var m:uint;		private var urlAr:Array = new Array();		private var urlPath:URLRequest;		private var urlLoader:Loader;		private var pageMC:MovieClip;		private var direct:Boolean;		public function PageFlip(){						this["mc2"].mask = this["masker1"];			this["area"].addEventListener(MouseEvent.CLICK,flipping);			/*area.addEventListener(MouseEvent.MOUSE_OVER,alertDrag);			area.addEventListener(MouseEvent.MOUSE_OUT,resumeInit);*/			/*area1.addEventListener(MouseEvent.MOUSE_OVER,backAlertDrag);			area1.addEventListener(MouseEvent.MOUSE_OUT,backResumeInit);*/			//this.addEventListener(Event.ENTER_FRAME,checkN);					}		public function xmlData(arr:Array):void{						urlAr = arr as Array;			m = urlAr.length;			this["area"].dispatchEvent(new MouseEvent("click"));					}		private function flipping(e:MouseEvent):void{						this["area"].removeEventListener(MouseEvent.CLICK,flipping);			direct = true;			if(n == (m-1)){								this["area"].removeEventListener(MouseEvent.CLICK,flipping);				this["area1"].addEventListener(MouseEvent.CLICK,flippingBack);				return;							}			if(n<m){								n++;				this["area1"].addEventListener(MouseEvent.CLICK,flippingBack);							}			trace("abel:"+n);			if(this["loadZone"].numChildren){								(this["loadZone"].getChildAt(0) as MovieClip).stop();							}			this.swapChildren(this["loadZone"],this["mc1"]);			this["shadowLine"].visible = true;			pointM = new Point(600,450);			this.addEventListener(Event.ENTER_FRAME,scrollToEnd);					}		private function scrollToEnd(e:Event):void{						pointM.x += (0-pointM.x)/5;			pointM.y += (500-pointM.y)/5;			this["mc1"].x = pointM.x;			this["mc1"].y = pointM.y;			beginDrawing();			if(pointM.x <=1){								this["area"].addEventListener(MouseEvent.CLICK,flipping);				this["shadowLine"].visible = false;				this.removeEventListener(Event.ENTER_FRAME,scrollToEnd);				if(this["loadZone"].numChildren){										(this["loadZone"].getChildAt(0) as MovieClip).stop();					this["loadZone"].removeChild(this["loadZone"].getChildAt(0));									}				loadPages();							}					}		private function flippingBack(e:MouseEvent):void{						this["area1"].removeEventListener(MouseEvent.CLICK,flippingBack);			direct = false;			if(n <= 0){								this["area1"].removeEventListener(MouseEvent.CLICK,flippingBack);				this["area"].addEventListener(MouseEvent.CLICK,flipping);				return;							}else{								n--;				this["area"].addEventListener(MouseEvent.CLICK,flipping);							}			if(this["loadZone"].numChildren){								(this["loadZone"].getChildAt(0) as MovieClip).stop();							}			this.swapChildren(this["loadZone"],this["mc3"]);			this["shadowLine1"].visible = true;			pointM = new Point(200,300);			this.addEventListener(Event.ENTER_FRAME,scrollBack);					}		private function scrollBack(e:Event):void{						pointM.x += (660-pointM.x)/2;			pointM.y += (500-pointM.y)/2;			//trace(pointM.x);			this["mc3"].x = pointM.x;			this["mc3"].y = pointM.y;			backMaskerBegin();			if(pointM.x >= 659){								this["area1"].addEventListener(MouseEvent.CLICK,flippingBack);				this["shadowLine1"].visible = false;				this.removeEventListener(Event.ENTER_FRAME,scrollBack);				if(this["loadZone"].numChildren){										(this["loadZone"].getChildAt(0) as MovieClip).stop();					this["loadZone"].removeChild(this["loadZone"].getChildAt(0));									}				loadPages();							}					}		private function loadPages():void{			//trace("n="+n);			//trace("url="+urlAr);			var url:String = urlAr[n];			urlLoader = new Loader();			urlPath = new URLRequest(url);			urlLoader.contentLoaderInfo.addEventListener(Event.COMPLETE,addPage);			urlLoader.load(urlPath);					}		public function stopMotion():void{						pageMC.stop();					}		private function addPage(e:Event):void{			trace(n);			pageMC = e.target.content as MovieClip;			this["loadZone"].addChild(pageMC);			if(direct){								this.swapChildren(this["loadZone"],this["mc1"]);				this["mc1"].x = 660;				this["mc1"].y = 500;							}else{								this.swapChildren(this["loadZone"],this["mc3"]);				this["mc3"].x = 0,				this["mc3"].y = 500;							}			urlLoader.contentLoaderInfo.removeEventListener(Event.COMPLETE,addPage);					}		private function alertDrag(e:MouseEvent):void{			pointM = new Point(660,500)			this["mc1"].alpha = 1;			this.addEventListener(Event.ENTER_FRAME,forWards);					}		private function resumeInit(e:MouseEvent):void{						this.removeEventListener(Event.ENTER_FRAME,forWards);			this.removeEventListener(Event.ENTER_FRAME,drawMasker);			this.addEventListener(Event.ENTER_FRAME,backWards);					}		private function forWards(e:Event):void{						pointM.x += (mouseX - pointM.x)/2;			pointM.y += (mouseY - pointM.y)/2;			this["mc1"].x = pointM.x;			this["mc1"].y = pointM.y;			beginDrawing();					}		private function backWards(e:Event):void{						pointM.x += (660 - pointM.x)/2;			pointM.y += (500 - pointM.y)/2;			this["mc1"].x = pointM.x;			this["mc1"].y = pointM.y;			beginDrawing();					}		private function autoFlip(e:MouseEvent):void{						this.addEventListener(Event.ENTER_FRAME,checkPointM);					}		private function checkPointM(e:Event):void{						this.removeEventListener(MouseEvent.MOUSE_UP,autoFlip);			this.removeEventListener(Event.ENTER_FRAME,drawMasker);			if(pointM.x < 330){								if(pointM.x <= 1){									this.removeEventListener(Event.ENTER_FRAME,checkPointM);					this["area"].addEventListener(MouseEvent.MOUSE_OVER,alertDrag);					this["area"].addEventListener(MouseEvent.MOUSE_OUT,resumeInit);					this["mc1"].mask = null;					n = n+1;					pointM = new Point(660,500);					this["mc1"].alpha = 0;					return;								}else{										pointM.x += (0-pointM.x)/2;									}							}			if(pointM.x > 330){								if(pointM.x >=659){										this.removeEventListener(Event.ENTER_FRAME,checkPointM);					this["area"].addEventListener(MouseEvent.MOUSE_OVER,alertDrag);					this["area"].addEventListener(MouseEvent.MOUSE_OUT,resumeInit);					return;									}else{										pointM.x += (660-pointM.x)/2;									}							}			pointM.y += (500-pointM.y)/2;			this["mc1"].x = pointM.x;			this["mc1"].y = pointM.y;			beginDrawing();					}		private function pointMHandler(e:MouseEvent):void{						this["area"].removeEventListener(MouseEvent.MOUSE_OVER,alertDrag);			this["area"].removeEventListener(MouseEvent.MOUSE_OUT,resumeInit);			this.removeEventListener(Event.ENTER_FRAME,backWards);			this.removeEventListener(Event.ENTER_FRAME,forWards);			this.addEventListener(MouseEvent.MOUSE_UP,autoFlip);			this.addEventListener(Event.ENTER_FRAME,drawMasker);					}		private function drawMasker(e:Event):void{						if(this["circle"].hitTestPoint(mouseX,mouseY,true)){								pointM.x += (mouseX - pointM.x)/2;				pointM.y += (mouseY - pointM.y)/2;							}else{								if(mouseX > 660){										var len:Number = 330-(mouseX-660);					pointM.x += (len +330 - pointM.x)/2;					pointM.y += (500-Math.sqrt(330*330-len*len) - pointM.y)/2;									}else{										var lena:Number = Math.abs(mouseX-330);					pointM.x += (Math.abs(mouseX) - pointM.x)/2;					pointM.y += (500-Math.sqrt(330*330-lena*lena) - pointM.y)/2;									}							}			this["mc1"].x = pointM.x;			this["mc1"].y = pointM.y;			beginDrawing();					}		private function beginDrawing():void{						this["mc1"].x = pointM.x;			this["mc1"].y = pointM.y;			this["shadowLine"].x = this["mc1"].x+250;			this["shadowLine"].y = this["mc1"].y+100;			var md:Number = Point.distance(pointD,pointM);			var dl:Number = 660-pointM.x;			var ml:Number = 500-pointM.y;			var mdl:Number = Math.atan2(ml,dl);			var dh:Number = md/2/Math.sin(mdl);			pointH.x = pointD.x;			pointH.y = pointD.y-dh;			pointI.x = pointD.x - md/2/Math.cos(mdl);			pointI.y = pointD.y;			if(pointH.y>pointB.y){								pointK.x = pointH.x;				pointK.y = pointH.y;							}else{								var bh:Number = Math.tan(mdl)*(dh-500);				var kha:Number = mdl*2;				pointK.x = pointB.x - (Math.cos(mdl/2)*bh+bh)				pointK.y = -(Math.sin(kha)*bh);				pointH.x = pointB.x - bh;				pointH.y = pointB.y;							}			masker.graphics.clear();			masker.graphics.beginFill(0x000000,1.0);			masker.graphics.moveTo(pointM.x,pointM.y);			masker.graphics.lineTo(pointK.x,pointK.y);			masker.graphics.lineTo(pointH.x,pointH.y);			masker.graphics.lineTo(pointI.x,pointI.y);			masker.graphics.lineTo(pointM.x,pointM.y);			masker.graphics.endFill();			this.addChild(masker);			this["mc1"].rotation = 2*mdl*180/Math.PI;			this["shadowLine"].rotation = this["mc1"].rotation-90;			this["mc1"].mask = masker;			masker1.graphics.clear();			masker1.graphics.beginFill(0xffffff,1.0);			masker1.graphics.moveTo(pointD.x,pointD.y);			masker1.graphics.lineTo(pointI.x,pointI.y);			masker1.graphics.lineTo(pointH.x,pointH.y);			masker1.graphics.lineTo(pointB.x,pointB.y);			masker1.graphics.lineTo(pointD.x,pointD.y);			masker1.graphics.endFill();			this.addChild(masker1);			this["mc2"].mask = masker1;					}	private function backPointM(e:MouseEvent):void{					this["area"].removeEventListener(MouseEvent.MOUSE_DOWN,pointMHandler);			this["area"].removeEventListener(MouseEvent.MOUSE_OVER,alertDrag);			this["area"].removeEventListener(MouseEvent.MOUSE_OUT,resumeInit);						this["area1"].removeEventListener(MouseEvent.MOUSE_OVER,backAlertDrag);			this["area1"].removeEventListener(MouseEvent.MOUSE_OUT,backResumeInit);			this.removeEventListener(Event.ENTER_FRAME,backForwards);			this.removeEventListener(Event.ENTER_FRAME,backBackwards);						this.addEventListener(MouseEvent.MOUSE_UP,backAutoFlip);			this.addEventListener(Event.ENTER_FRAME,backMasker);				}	private function backMasker(e:Event):void{						if(this["circle"].hitTestPoint(mouseX,mouseY,true)){								pointM.x += (mouseX - pointM.x)/2;				pointM.y += (mouseY - pointM.y)/2;							}else{									pointM.x = pointM.x;					pointM.y = pointM.y;								}			this["mc3"].x = pointM.x;			this["mc3"].y = pointM.y;			this["shadowLine"].x = this["mc3"].x;			this["shadowLine"].y = this["mc3"].y;			backMaskerBegin();					}		private function backMaskerBegin():void{						this["mc3"].x = pointM.x;			this["mc3"].y = pointM.y;			this["shadowLine1"].x = this["mc3"].x-250;			this["shadowLine1"].y = this["mc3"].y+100;			var md:Number = Point.distance(pointC,pointM);			var dl:Number = pointM.x;			var ml:Number = 500-pointM.y;			var mdl:Number = Math.atan2(ml,dl);			var dh:Number = md/2/Math.sin(mdl);			pointH.x = pointC.x;			pointH.y = pointC.y-dh;			pointI.x = pointC.x + md/2/Math.cos(mdl);			pointI.y = pointC.y;			if(pointH.y>pointA.y){								pointK.x = pointH.x;				pointK.y = pointH.y;							}else{								var bh:Number = Math.tan(mdl)*(dh-500);				var kha:Number = mdl*2;				pointK.x = pointA.x + (Math.cos(mdl/2)*bh+bh)				pointK.y = -(Math.sin(kha)*bh);				pointH.x = pointA.x + bh;				pointH.y = pointA.y;							}			masker.graphics.clear();			masker.graphics.beginFill(0x000000,1.0);			masker.graphics.moveTo(pointM.x,pointM.y);			masker.graphics.lineTo(pointK.x,pointK.y);			masker.graphics.lineTo(pointH.x,pointH.y);			masker.graphics.lineTo(pointI.x,pointI.y);			masker.graphics.lineTo(pointM.x,pointM.y);			masker.graphics.endFill();			this["mc3"].rotation = -2*mdl*180/Math.PI;			this["shadowLine1"].rotation = this["mc3"].rotation-90;			this["mc3"].mask = masker;			masker1.graphics.clear();			masker1.graphics.beginFill(0xffffff,1.0);			masker1.graphics.moveTo(pointC.x,pointC.y);			masker1.graphics.lineTo(pointI.x,pointI.y);			masker1.graphics.lineTo(pointH.x,pointH.y);			masker1.graphics.lineTo(pointA.x,pointA.y);			masker1.graphics.lineTo(pointC.x,pointC.y);			masker1.graphics.endFill();			this["mc2"].mask = masker1;					}		private function backAlertDrag(e:MouseEvent):void{						pointM = new Point(0,500);			this["mc3"].alpha = 1;			this.addEventListener(Event.ENTER_FRAME,backForwards);					}		private function backResumeInit(e:MouseEvent):void{						this.removeEventListener(Event.ENTER_FRAME,backForwards);			this.removeEventListener(Event.ENTER_FRAME,backMasker);			this.addEventListener(Event.ENTER_FRAME,backBackwards);					}		private function backForwards(e:Event):void{						pointM.x += (mouseX - pointM.x)/2;			pointM.y += (mouseY - pointM.y)/2;			this["mc3"].x = pointM.x;			this["mc3"].y = pointM.y;			backMaskerBegin();					}		private function backBackwards(e:Event):void{						pointM.x += (0 - pointM.x)/2;			pointM.y += (500 - pointM.y)/2;			this["mc3"].x = pointM.x;			this["mc3"].y = pointM.y;			backMaskerBegin();					}		private function backAutoFlip(e:MouseEvent):void{						this.addEventListener(Event.ENTER_FRAME,checkBackPointM);					}		private function checkBackPointM(e:Event):void{						this.removeEventListener(MouseEvent.MOUSE_UP,backAutoFlip);			this.removeEventListener(Event.ENTER_FRAME,backMasker);			if(pointM.x < 330){								if(pointM.x <= 1){									this.removeEventListener(Event.ENTER_FRAME,checkBackPointM);					this["area1"].addEventListener(MouseEvent.MOUSE_OVER,backAlertDrag);					this["area1"].addEventListener(MouseEvent.MOUSE_OUT,backResumeInit);					this["area"].addEventListener(MouseEvent.MOUSE_DOWN,pointMHandler);					this["area"].addEventListener(MouseEvent.MOUSE_OVER,alertDrag);					this["area"].addEventListener(MouseEvent.MOUSE_OUT,resumeInit);					return;								}else{										pointM.x += (0-pointM.x)/2;									}							}			if(pointM.x > 330){								if(pointM.x >=659){										this.removeEventListener(Event.ENTER_FRAME,checkBackPointM);					this["area1"].addEventListener(MouseEvent.MOUSE_OVER,backAlertDrag);					this["area1"].addEventListener(MouseEvent.MOUSE_OUT,backResumeInit);					this["area"].addEventListener(MouseEvent.MOUSE_DOWN,pointMHandler);					this["area"].addEventListener(MouseEvent.MOUSE_OVER,alertDrag);					this["area"].addEventListener(MouseEvent.MOUSE_OUT,resumeInit);					this["mc3"].mask = null;					this["mc3"].alpha = 0;					pointM = new Point(0,500);					n = n+1;					return;									}else{										pointM.x += (660-pointM.x)/2;									}							}			pointM.y += (500-pointM.y)/2;			this["mc3"].x = pointM.x;			this["mc3"].y = pointM.y;			backMaskerBegin();					}	}}